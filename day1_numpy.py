# -*- coding: utf-8 -*-
"""Day1_Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13KAUCtkoMq0i5alr4K7K3c6rbapR8Kkr

**Numpy:**

Numpy is a Python library for scientific computing that supports multi-dimensional arrays and their manipulation.


**Why Numpy over lists?**

* Lists are faster than Numpy

  * Lists can store multiple data types at once, but Numpy doesn't. So every element in a numpy array need not undergo type checking.
  * Numpy stores data in fixed type ie. 5 is stored as 00000101 (int32 type) always. Whereas storing of elements in lists require a lot of meta data like Size, Object Type, Object Value, Reference Count, this means every element takes up much more space. Thus due to the larger space, lists are slower than numpy. 

* Lists are scattered in memory. But numpy uses contiguous memory. 
 * Allows SIMD (Single Input Multiple Data) vector processing
 * Better Cache utilization

Importing Numpy Library
"""

import numpy as np

# Creating a Simple 1-D array
a = np.array([1, 2, 3])
print(a)

# Creating 2-D array 
a= np.array([[1.0, 2.0], [3.0, 4.0]])
print(a)

print(a.ndim)

print(a.shape)

print(a.dtype)
print(a.itemsize)

# By default int32 is used. we can assign our own datatype while creating the array
b = np.array([1, 2, 3], dtype = "int16")
print(b.dtype)
print(b.itemsize) # Size of elements in bytes

## Number of elements in array
print(b.size)

## Memory size of array 
print(b.nbytes)

"""**Manipulating Numpy array**"""

a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13 ,14, 15]])
print(a)
print(a.shape)

# Accessing a specific element. NOTE: Numpy arrays are 0-indexed
print(a[2, 3])

# Accessing a full row: 
print(a[1, :])

# Accessing full column:
print(a[:, 1])

# Numpy allows negative indexing like lists
print(a[1, -1]) # first row, last element 

# Accessing a range of elements
print(a[0:2, 1:-2]) ## The closing index is not included

#Accessing a range of values by steps
print(a[: , ::2]) # accessing every 2nd element

# Changing an element
print(a[1, 2])
a[1,2] = 3
print(a[1, 2])

# Changing values of a series of elements

print(a[: , 1:3])
a[: , 1:3] = [1, 2]
print(a[: , 1:3])

# lesser assignment than available length
print(a[: , 1:4])
a[: , 1:4] = [1, 2] # Throws an error due to input size mismatch
print(a[: , 1:4])

"""3-D array example"""

b = np.array([[[1, 2], [3, 4]], [[4, 5], [6, 7]]])
print(b.ndim)

# accessing elements works outside in. 

b[1, : , 1] = [11, 12]
print(b)

"""**Initializing different types of arrays**"""

# all zeros
np.zeros((10))
np.zeros((3, 2, 2), dtype = 'int32')

# all ones
np.ones((2, 2, 2, 3 ), dtype="int16")

# All elements of a particular number 
np.full((5,5), 10)
np.full(a.shape, 11)

## similar to full, full_like
np.full_like(a, 12) # copies the shape of the existing matrix with the values given by the user

## Creating a random decimal array 
np.random.rand(2,2,2)

### creating a random integer array 
np.random.randint(2, 15, size = (2, 2, 2))

## Creating an identity matrix 
np.identity(5) # The identity matrix by nature is square shaped

### Repeating an array 
a = np.array([[1, 2, 3]])
output = np.repeat(a, 3, axis=0) #axis = 0, represents rows and axis = 1 represents columns 
print(output)

"""**Exercise 1** 

1 1 1 1 1

1 0 0 0 1

1 0 9 0 1

1 0 0 0 1

1 1 1 1 1

Create the above array using numpy (not mannualy)
"""

matrix = np.ones((5, 5), dtype = "int32")
sub_matrix = np.zeros((3, 3), dtype = "int32")
matrix[1:4, 1:4] = sub_matrix

matrix[2, 2]=9

print(matrix)

"""Making a new copy of an array (Careful)"""

a = np.array([1, 2, 3])
b = a
b[1] = 100
print(a[1])

## When we do b=a, we are just making b point to the adress of a. we didn't make a new copy.

## To make a new cophy of array use a.copy()
a = np.array([1, 2, 3])
b = a.copy()
b[1] = 100
print(a[1])

"""**Element wise operations**"""

a = np.array([1, 2, 3, 4])
print(a+1)
print(a-1)
print(a/1)
print(a*2)
print(a**2)
print(a**3)
print(a%2)
print(np.sin(a))
print(np.cos(a))
print(np.tan(a))


b= np.array([1,2,3,4])
print(a*b)

"""**Matrix calculations**"""

a = np.array([[1,2, 3], [1, 2, 3]])
b = np.ones((3,3))
print(np.matmul(a, b)) # Matrix multiplication

print(np.linalg.det(b)) # matrix determinant calculation

"""**Statistics Functions**"""

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

print(np.min(a))
print(np.max(a))
print(np.sum(a))
print(np.max(a, axis = 0))
print(np.max(a, axis = 1))

print(a.shape)
b= a.reshape((4,3)) # reshape is not inplace, we have to explicitly store it into a new result array 
print(b)

"""**Horizontal and Vertical Stacking**"""

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

print(np.vstack([a,b, a, b, a])) # The arrangement of arrays inside the stack must always be passed as a list

print(np.hstack([a,b,a]))

"""**Load Data From File**"""

data = np.genfromtxt('Sample_Data.txt', delimiter=",")
print(data)
print(data.dtype)
data = data.astype('int32')
print(data.dtype)

"""**Boolean Masking and Advanced indexing**"""

print(data > 5)
print((data % 2 ==0) & (data > 5))
print(data[(data % 2 ==0) & (data > 5)])

